Домашнее задание 1\. Обход файлов

1.  Разработайте класс <tt>Walk</tt>, осуществляющий подсчет хеш-сумм файлов.
    1.  Формат запуска

        <pre>java Walk <входной файл> <выходной файл></pre>

    2.  Входной файл содержит список файлов, которые требуется обойти.
    3.  Выходной файл должен содержать по одной строке для каждого файла. Формат строки:

        <pre><шестнадцатеричная хеш-сумма> <путь к файлу></pre>

    4.  Для подсчета хеш-суммы используйте алгоритм [FNV](https://ru.wikipedia.org/wiki/FNV).
    5.  Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы <tt>00000000</tt>.
    6.  Кодировка входного и выходного файлов — UTF-8.
    7.  Если родительская директория выходного файла не существует, то соответствующий путь надо создать.
    8.  Размеры файлов могут превышать размер оперативной памяти.
    9.  Пример

        Входной файл

        <pre>                        java/info/kgeorgiy/java/advanced/walk/samples/1
                                java/info/kgeorgiy/java/advanced/walk/samples/12
                                java/info/kgeorgiy/java/advanced/walk/samples/123
                                java/info/kgeorgiy/java/advanced/walk/samples/1234
                                java/info/kgeorgiy/java/advanced/walk/samples/1
                                java/info/kgeorgiy/java/advanced/walk/samples/binary
                                java/info/kgeorgiy/java/advanced/walk/samples/no-such-file
                            </pre>

        Выходной файл

        <pre>                        050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
                                2076af58 java/info/kgeorgiy/java/advanced/walk/samples/12
                                72d607bb java/info/kgeorgiy/java/advanced/walk/samples/123
                                81ee2b55 java/info/kgeorgiy/java/advanced/walk/samples/1234
                                050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
                                8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
                                00000000 java/info/kgeorgiy/java/advanced/walk/samples/no-such-file
                            </pre>

2.  Усложненная версия:
    1.  Разработайте класс <tt>RecursiveWalk</tt>, осуществляющий подсчет хеш-сумм файлов в директориях
    2.  Входной файл содержит список файлов и директорий, которые требуется обойти. Обход директорий осуществляется рекурсивно.
    3.  Пример

        Входной файл

        <pre>                        java/info/kgeorgiy/java/advanced/walk/samples/binary
                                java/info/kgeorgiy/java/advanced/walk/samples
                            </pre>

        Выходной файл

        <pre>                        8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
                                050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
                                2076af58 java/info/kgeorgiy/java/advanced/walk/samples/12
                                72d607bb java/info/kgeorgiy/java/advanced/walk/samples/123
                                81ee2b55 java/info/kgeorgiy/java/advanced/walk/samples/1234
                                8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
                            </pre>

3.  При выполнении задания следует обратить внимание на:
    *   Дизайн и обработку исключений, диагностику ошибок.
    *   Программа должна корректно завершаться даже в случае ошибки.
    *   Корректная работа с вводом-выводом.
    *   Отсутствие утечки ресурсов.
4.  Требования к оформлению задания.
    *   Проверяется исходный код задания.
    *   Весь код должен находиться в пакете <tt>ru.ifmo.rain.фамилия.walk</tt>.

[Тесты к домашним заданиям](https://www.kgeorgiy.info/git/geo/java-advanced-2019)

### Домашнее задание 2\. Множество на массиве

1.  Разработайте класс <tt>ArraySet</tt>, реализующие неизменяемое упорядоченное множество.
    *   Класс <tt>ArraySet</tt> должен реализовывать интерфейс <tt>SortedSet</tt> (упрощенная версия) или <tt>NavigableSet</tt> (усложненная версия).
    *   Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
2.  При выполнении задания следует обратить внимание на:
    *   Применение стандартных коллекций.
    *   Избавление от повторяющегося кода.

### Домашнее задание 3\. Студенты

1.  Разработайте класс <tt>StudentDB</tt>, осуществляющий поиск по базе данных студентов.
    *   Класс <tt>StudentDB</tt> должен реализовывать интерфейс <tt>StudentQuery</tt> (простая версия) или <tt>StudentGroupQuery</tt> (сложная версия).
    *   Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько строк.
2.  При выполнении задания следует обратить внимание на:
    *   Применение лямбда-выражений и потоков.
    *   Избавление от повторяющегося кода.

### Домашнее задание 4\. Implementor

1.  Реализуйте класс <tt>Implementor</tt>, который будет генерировать реализации классов и интерфейсов.
    *   Аргументы командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
    *   В результате работы должен быть сгенерирован java-код класса с суффиксом <tt>Impl</tt>, расширяющий (реализующий) указанный класс (интерфейс).
    *   Сгенерированный класс должен компилироваться без ошибок.
    *   Сгенерированный класс не должен быть абстрактным.
    *   Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
2.  В задании выделяются три уровня сложности:
    *   _Простой_ — <tt>Implementor</tt> должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.
    *   _Сложный_ — <tt>Implementor</tt> должен уметь реализовывать и классы и интерфейсы. Поддержка generics не требуется.
    *   _Бонусный_ — <tt>Implementor</tt> должен уметь реализовывать generic-классы и интерфейсы. Сгенерированный код должен иметь корректные параметры типов и не порождать <tt>UncheckedWarning</tt>.

### Домашнее задание 5\. Jar Implementor

1.  Создайте <tt>.jar</tt>-файл, содержащий скомпилированный <tt>Implementor</tt> и сопутствующие классы.
    *   Созданный <tt>.jar</tt>-файл должен запускаться командой <tt>java -jar</tt>.
    *   Запускаемый <tt>.jar</tt>-файл должен принимать те же аргументы командной строки, что и класс <tt>Implementor</tt>.
2.  Модифицируйте <tt>Implemetor</tt> так, что бы при запуске с аргументами <tt>-jar имя-класса файл.jar</tt> он генерировал <tt>.jar</tt>-файл с реализацией соответствующего класса (интерфейса).
3.  Для проверки, кроме исходного кода так же должны быть предъявлены:
    *   скрипт для создания запускаемого <tt>.jar</tt>-файла, в том числе, исходный код манифеста;
    *   запускаемый <tt>.jar</tt>-файл.
4.  Данное домашнее задание сдается только вместе с предыдущим. Предыдущее домашнее задание отдельно сдать будет нельзя.
5.  **Сложная версия**. Решение должно быть модуляризовано.

### Домашнее задание 6\. Javadoc

1.  Документируйте класс <tt>Implementor</tt> и сопутствующие классы с применением Javadoc.
    *   Должны быть документированы все классы и все члены классов, в том числе закрытые (<tt>private</tt>).
    *   Документация должна генерироваться без предупреждений.
    *   Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки.
2.  Для проверки, кроме исходного кода так же должны быть предъявлены:
    *   скрипт для генерации документации;
    *   сгенерированная документация.
3.  Данное домашнее задание сдается только вместе с предыдущим. Предыдущее домашнее задание отдельно сдать будет нельзя.

### Домашнее задание 7\. Итеративный параллелизм

1.  Реализуйте класс <tt>IterativeParallelism</tt>, который будет обрабатывать списки в несколько потоков.
2.  В _простом_ варианте должны быть реализованы следующие методы:
    *   <tt>minimum(threads, list, comparator)</tt> — первый минимум;
    *   <tt>maximum(threads, list, comparator)</tt> — первый максимум;
    *   <tt>all(threads, list, predicate)</tt> — проверка, что все элементы списка удовлетворяют [предикату](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html);
    *   <tt>any(threads, list, predicate)</tt> — проверка, что существует элемент списка, удовлетворяющий [предикату](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html).
3.  В _сложном_ варианте должны быть дополнительно реализованы следующие методы:
    *   <tt>filter(threads, list, predicate)</tt> — вернуть список, содержащий элементы удовлетворяющие [предикату](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html);
    *   <tt>map(threads, list, function)</tt> — вернуть список, содержащий результаты применения [функции](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html);
    *   <tt>join(threads, list)</tt> — конкатенация строковых представлений элементов списка.
4.  Во все функции передается параметр <tt>threads</tt> — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков не велико.
5.  Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
6.  При выполнении задания нельзя использовать _Concurrency Utilities_.
7.  Рекомендуется подумать, какое отношение к заданию имеют [моноиды](https://en.wikipedia.org/wiki/Monoid).

### Домашнее задание 8\. Параллельный запуск

1.  Напишите класс <tt>ParallelMapperImpl</tt>, реализующий интерфейс <tt>ParallelMapper</tt>.

    <pre>public interface ParallelMapper extends AutoCloseable {
        <T, R> List<R> run(
            Function<? super T, ? extends R> f, 
            List<? extends T> args
        ) throws InterruptedException;

        @Override
        void close() throws InterruptedException;
    }
    </pre>

    *   Метод <tt>run</tt> должен параллельно вычислять функцию <tt>f</tt> на каждом из указанных аргументов (<tt>args</tt>).
    *   Метод <tt>close</tt> должен останавливать все рабочие потоки.
    *   Конструктор <tt>ParallelMapperImpl(int threads)</tt> создает <tt>threads</tt> рабочих потоков, которые могут быть использованы для распараллеливания.
    *   К одному <tt>ParallelMapperImpl</tt> могут одновременно обращаться несколько клиентов.
    *   Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
    *   В реализации не должно быть активных ожиданий.
2.  Модифицируйте касс <tt>IterativeParallelism</tt> так, чтобы он мог использовать <tt>ParallelMapper</tt>.
    *   Добавьте конструктор <tt>IterativeParallelism(ParallelMapper)</tt>
    *   Методы класса должны делить работу на <tt>threads</tt> фрагментов и исполнять их при помощи <tt>ParallelMapper</tt>.
    *   Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один <tt>ParallelMapper</tt>.
    *   При наличии <tt>ParallelMapper</tt> сам <tt>IterativeParallelism</tt> новые потоки создавать не должен.

### Домашнее задание 9\. Web Crawler

1.  Напишите потокобезопасный класс <tt>WebCrawler</tt>, который будет рекурсивно обходить сайты.
    1.  Класс <tt>WebCrawler</tt> должен иметь конструктор

        <pre>                        public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)
                            </pre>

        *   <tt>downloader</tt> позволяет скачивать страницы и извлекать из них ссылки;
        *   <tt>downloaders</tt> — максимальное число одновременно загружаемых страниц;
        *   <tt>extractors</tt> — максимальное число страниц, из которых извлекаются ссылки;
        *   <tt>perHost</tt> — максимальное число страниц, одновременно загружаемых c одного хоста. Для опредения хоста следует использовать метод <tt>getHost</tt> класса <tt>URLUtils</tt> из тестов.
    2.  Класс <tt>WebCrawler</tt> должен реализовывать интерфейс <tt>Crawler</tt>

        <pre>                        public interface Crawler extends AutoCloseable {
                                    List<String> download(String url, int depth) throws IOException;

                                    void close();
                                }
                            </pre>

        *   Метод <tt>download</tt> должен рекурсивно обходить страницы, начиная с указанного URL на указанную глубину и возвращать список загруженных страниц и файлов. Например, если глубина равна 1, то должна быть загружена только указанная страница. Если глубина равна 2, то указанная страница и те страницы и файлы, на которые она ссылается и так далее. Этот метод может вызываться параллельно в нескольких потоках.
        *   Загрузка и обработка страниц (извлечение ссылок) должна выполняться максимально параллельно, с учетом ограничений на число одновременно загружаемых страниц (в том числе с одного хоста) и страниц, с которых загружаются ссылки.
        *   Для распараллеливания разрешается создать до <tt>downloaders + extractors</tt> вспомогательных потоков.
        *   Загружать и/или извлекать ссылки из одной и той же страницы в рамках одного обхода (<tt>download</tt>) запрещается.
        *   Метод <tt>close</tt> должен завершать все вспомогательные потоки.
    3.  Для загрузки страниц должен применяться <tt>Downloader</tt>, передаваемый первым аргументом конструктора.

        <pre>                        public interface Downloader {
                                    public Document download(final String url) throws IOException;
                                }
                            </pre>

        *   Метод <tt>download</tt> загружает документ по его адресу ([URL](http://tools.ietf.org/html/rfc3986)).
        *   Документ позволяет получить ссылки по загруженной странице:

            <pre>                    public interface Document {
                                    List<String> extractLinks() throws IOException;
                                }
                            </pre>

            Ссылки, возвращаемые документом являются абсолютными и имеют схему <tt>http</tt> или <tt>https</tt>.
    4.  Должен быть реализован метод <tt>main</tt>, позволяющий запустить обход из командной строки
        *   Командная строка

            <pre>                    WebCrawler url [depth [downloads [extractors [perHost]]]]
                            </pre>

        *   Для загрузки страниц требуется использовать реализацию <tt>CachingDownloader</tt> из тестов.
2.  Версии задания
    1.  _Простая_ — можно не учитывать ограничения на число одновременных закачек с одного хоста <tt>(perHost >= downloaders)</tt>.
    2.  _Полная_ — требуется учитывать все ограничения.
    3.  _Бонусная_ — сделать параллельный обод в ширину.

### Домашнее задание 10\. HelloUDP

1.  Реализуйте клиент и сервер, взаимодействующие по UDP.
2.  Класс <tt>HelloUDPClient</tt> должен отправлять запросы на сервер, принимать результаты и выводить их на консоль.
    *   Аргументы командной строки:
        1.  имя или ip-адрес компьютера, на котором запущен сервер;
        2.  номер порта, на который отсылать запросы;
        3.  префикс запросов (строка);
        4.  число параллельных потоков запросов;
        5.  число запросов в каждом потоке.
    *   Запросы должны одновременно отсылаться в указанном числе потоков. Каждый поток должен ожидать обработки своего запроса и выводить сам запрос и результат его обработки на консоль. Если запрос не был обработан, требуется послать его заного.
    *   Запросы должны формироваться по схеме <tt><префикс запросов><номер потока>_<номер запроса в потоке></tt>.
3.  Класс <tt>HelloUDPServer</tt> должен принимать задания, отсылаемые классом <tt>HelloUDPClient</tt> и отвечать на них.
    *   Аргументы командной строки:
        1.  номер порта, по которому будут приниматься запросы;
        2.  число рабочих потоков, которые будут обрабатывать запросы.
    *   Ответом на запрос должно быть <tt>Hello, <текст запроса></tt>.
    *   Если сервер не успевает обрабатывать запросы, прием запросов может быть временно приостановлен.
4.  _Бонусный вариант_. Реализация должна быть полностью неблокирующей.
    *   Клиент не должен создавать потоков.
    *   В реализации не должно быть активных ожиданий, в том числе через `Selector`.
